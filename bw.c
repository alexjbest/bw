#include <stdio.h>
#include <gmp.h>
#include "m4ri.h"
#include "flint.h"
#include "ulong_extras.h"
#include "nmod_sparse_mat.h"
#define MZD_MUL_CUTOFF 4096

static inline double myrand() {
    /* ******************************************************************
       Generates a random floating-point number between -1.0 and
       1.0. Not sure if this is the best precision possible, but is
       based on bitwise operations, and I believe it should be faster
       than using (float)rand()/RAND_MAX.

       We pick up the number generated by rand, and leave just the bits
       over the mantissa region. The signal and exponent part are
       replaced to generate a number between 1.0 and 1.9999999. We
       then subtract 1.0 to bring the range down to 0.0 and 0.9999999.

       Coded in 2010-09-24 by Nicolau Werneck <nwerneck@gmail.com>.
     *************************************************************** */
    static union {
        unsigned  int i;
        float f;
    } myrand;
    myrand.i = (rand() & 0x007fffff) | 0x3f800000;
    return myrand.f-1.0;
}

void
nmod_sparse_mat_mul_m4ri_mat_w1(mzd_t* C, const nmod_sparse_mat_t A, const mzd_t *B)
{
    int i, k;
    for (i = 0; i < A->r; i++)
    {
        for (k = 0; k < A->row_supports[i]; k++)
        {
            /*mzd_xor_bits(C, i, j, m4ri_radix, *(mzd_row(B, A->rows[i][k].pos) + j));*/
            C->rows[i][0] ^= B->rows[A->rows[i][k].pos][0];
        }
    }
}
void
nmod_sparse_mat_mul_m4ri_mat(mzd_t* C, const nmod_sparse_mat_t A, const mzd_t *B)
{
    int i, j, k;
    mzd_set_ui(C, 0);
    if (B->width == 1)
    {
        nmod_sparse_mat_mul_m4ri_mat_w1(C, A, B);
        return;
    }

    for (i = 0; i < A->r; i++)
    {
        for (k = 0; k < A->row_supports[i]; k++)
        {
            const int p = A->rows[i][k].pos;
            for (j = 0; j < B->width; j++)
            {
                C->rows[i][j] ^= B->rows[p][j];
            }
        }
    }
}

struct pair
{
    int key;
    int value;
};

int compare(const void* a, const void* b)
{
     int ka = ( (struct pair *) a)->key;
     int kb = ( (struct pair *) b)->key;

     return (ka - kb);
}

void
ALGO1(mzd_t ** P, mzd_t * Xe, int * delta)
{
    mzd_t * XeT, * PT, *tmp;
    int i, j;
    int m = Xe->nrows;
    int n = Xe->ncols - Xe->nrows;

    tmp = mzd_transpose(NULL, Xe);
    XeT = mzd_init(Xe->ncols, Xe->nrows);
    PT = mzd_init(m + n, m + n);

    struct pair Delta[m + n];
    for (i = 0; i < m + n; i++)
    {
        Delta[i].key = delta[i];
        Delta[i].value = i;
    }

    qsort(Delta, m + n, sizeof(struct pair), compare);

    mzd_set_ui(PT, 0);
    for (i = 0; i < m + n; i++)
        mzd_write_bit(PT, i, Delta[i].value, 1);
    mzd_mul(XeT, PT, tmp, MZD_MUL_CUTOFF);                       /*!!!!!!! MISSING IN PAPER */
    mzd_free(tmp);

    for (i = 0; i < m + n; i++)
        delta[i] = Delta[i].key;

    int busy[m + n];
    for (i = 0; i < m + n; i++)
        busy[i] = 0;

    for (i = 0; i < m; i++)
    {
        int j0;
        for (j0 = 0; j0 < m + n; j0++) /* find a pivot */
            if (mzd_read_bit(XeT, j0, i) && !busy[j0])
                break;
        if (j0 < m + n)                                                 //MISSING IN PAPER??
        {
            busy[j0] = 1;
            for (j = j0 + 1; j < m + n; j++)
            {
                if (mzd_read_bit(XeT, j, i))
                {
                    mzd_row_add(XeT, j0, j);
                    mzd_row_add(PT, j0, j);
                }
            }
        }
        else {
            assert(0);
        }
    }

    mzd_transpose(Xe, XeT);
    mzd_transpose(P[0], PT);
    mzd_set_ui(P[1], 0);

    for (j = 0; j < m + n; j++)
    {
        if (busy[j])
        {
            /* TODO do this better, with mul and neg? */
            for (i = 0; i < P[0]->nrows; i++)
            {
                mzd_write_bit(P[1], i, j, mzd_read_bit(P[0], i, j));
                mzd_write_bit(P[0], i, j, 0);
            }
        }
    }
    mzd_free(XeT);
    mzd_free(PT);
}

/*
slong
berlekamp_massey(mzd_t ** qi, mzd_t **mty, const slong size)
{
    return 0;
}
*/

/*
 * This is an implementation of Coppersmith's block Wiedemann algorithm.
 * It follows the article "Fast computation of linear generators for matrix sequences
 * and application to the block Wiedemann algorithm" by Emmanuel Thome.
 */
void
bw(mzd_t *K, const nmod_sparse_mat_t M)
{
    mzd_t *e, *x, *id, *zero, **mtz, **mty, **xmty, **P, **f;
    const slong N = M->r, m = 64, n = 64;
    slong i, j;
    const int skip = 1, epsilon = 1;
    int done = 0, ftries, t = (m + n - 1)/n + skip, delta[m + n];
    int L = (N+m-1)/m + N/n + epsilon, max_diff;
    /* TODO check the correct things are const */

    /* set up dense matrices */
    x = mzd_init(m, N);
    mtz = (mzd_t **)malloc((L + 1) * sizeof(mzd_t *));
    mty = &mtz[1];
    xmty = (mzd_t **)malloc(L * sizeof(mzd_t *));
    P = (mzd_t **)malloc(2 * sizeof(mzd_t *)); /* a pair of matrices */
    f = (mzd_t **)malloc((t + 1) * sizeof(mzd_t *));
    P[0] = mzd_init(m + n, m + n);
    P[1] = mzd_init(m + n, m + n);
    mtz[0] = mzd_init(N, n);

    for (i = 0; i < L; i++)
    {
        mty[i] = mzd_init(N, n);
        xmty[i] = mzd_init(m, n);
    }

    for (i = 0; i <= t; i++)
        f[i] = mzd_init(n, m + n);

    for (i = 0; i < n + m; i++)
        delta[i] = t;

    zero = mzd_init(n, m);
    id = mzd_init(n, n);
    mzd_set_ui(id, 1);
    mzd_concat(f[t], zero, id);
    mzd_free(id);
    mzd_free(zero);

    /*mzd_t * ret(B.getField(),0,B->nrows);*/

    e = mzd_init(m, m + n);
    while (!done)
    {
        /* random initial y = Mz = mty[0] and x */
        mzd_randomize(mtz[0]);
        mzd_randomize(x);

        for (i = 0; i < L; i++)
        {
            nmod_sparse_mat_mul_m4ri_mat(mty[i], M, mtz[i]);
            mzd_mul(xmty[i], x, mty[i], MZD_MUL_CUTOFF);
        }

        for (ftries = 0; ftries <= 10 && !done; ftries++)
        {
            mzd_mul(e, xmty[0], f[t], MZD_MUL_CUTOFF);
            mzd_t * m_cols;
            for (i = 0; i < t; i++)
            {
                /*ithCoefficientOfVectorPolynomialProduct(B.getField(),m,m+n,AX,f,t);*/
                mzd_randomize(f[i]);
                for (j = 0; j < f[i]->nrows; j++)
                    mzd_row_clear_offset(f[i], j, m);
                mzd_addmul(e, xmty[t - i], f[i], MZD_MUL_CUTOFF);
            }


            m_cols = mzd_submatrix(NULL, e, 0, 0, m, m);
            done = (mzd_echelonize(m_cols, 0) == m);
            mzd_free(m_cols);
        }
    }

    for (max_diff = 0; max_diff <= N/m; t++, max_diff++)
    {
        mzd_t * f_tmp;

#if 0
        {//debug printing
            vector<mzd_t *> g;
            debug<<"Printing figure"<<" t "<<t<<" smallest t-deltaj:"<< t-delta.max()<<"\n";
            debug<<"AX.size()="<<(int)AX.size()<<"\n";
            debug<<"f.size()="<<(int)f.size()<<"\n";
            for (int i=0;i<100;i++)g.push_back(ithCoefficientOfVectorPolynomialProduct(B.getField(),m,m+n,AX,f,i));
            for (int i=0;i<m+n;i++)
            {
                debug<<i<<"\tdelta="<<delta[i]<<"\t"<<"degf "<<degreeOfIthColumn(f,i)<<" "<<degreeOfIthColumnREV(f,i)<<"\t";
                assert(degreeOfIthColumn(f,i)<=delta[i]);
                for (int j=0;j<100;j++)
                    debug<<(g[j].transposed()[i].isZero()?" ":"*");
                debug<<"|\n";
            }
        }
#endif

        /*mzd_t * e = ithCoefficientOfVectorPolynomialProduct(B.getField(),m,m+n,AX,f,t);
         * */

        if (done) /* first run only */
        {
            done = 0;
        }
        else
        {
            mzd_set_ui(e, 0);
            for (i = 0; i <= t; i++)
                mzd_addmul(e, xmty[t - i], f[i], MZD_MUL_CUTOFF);
        }

        ALGO1(P, e, delta);

        /*
        printf("P0:\n");
        mzd_print(P[0]);
        printf("P1:\n");
        mzd_print(P[1]);
        */

        /* f = productWithLinear(B.getField(), n, m + n, f, P);*/
        f = (mzd_t **)realloc(f, (t + 2) * sizeof(mzd_t *));
        f[t + 1] = mzd_init(n, m + n);
        f_tmp = mzd_init(n, m + n);
        mzd_mul(f[t + 1], f[t], P[1], MZD_MUL_CUTOFF);
        for (i = t; i >= 1; i--)
        {
            mzd_mul(f_tmp, f[i], P[0], MZD_MUL_CUTOFF);
            mzd_copy(f[i], f_tmp);
            mzd_addmul(f[i], f[i - 1], P[1], MZD_MUL_CUTOFF);
        }
        mzd_mul(f_tmp, f[0], P[0], MZD_MUL_CUTOFF);
        mzd_copy(f[0], f_tmp);

        max_diff = 0;
        for (i = 0; i < m + n; i++)
        {
            for (j = 0; j < m + n; j++)
            {
                if (mzd_read_bit(P[1], j, i))
                {
                    delta[i]++;
                    break;
                }
            }

            if (t - delta[i] > max_diff)
                max_diff = t - delta[i];
        }

        mzd_free(f_tmp);
    }

    /* extract kernel vector */
    printf("fin\n");

    printf("kernel vecs:\n");
    mzd_t *w, *wT, *Mw, *f_w, ** mtzT, **fT;
    w = mzd_init(N, 1);
    wT = mzd_init(1, N);
    Mw = mzd_init(N, 1);
    mtzT = (mzd_t **)malloc((L + 1) * sizeof(mzd_t *));
    fT = (mzd_t **)malloc((t + 1) * sizeof(mzd_t *));
    for (j = 0; j < L + 1; j++)
        mtzT[j] = mzd_transpose(NULL, mtz[j]);
    for (j = 0; j < t + 1; j++)
        fT[j] = mzd_transpose(NULL, f[j]);
    for (j = 0; j < m + n; j++)
    {
        /*printf("%ld, %d, %d\n", j, delta[j], t- delta[j]);*/
        mzd_set_ui(wT, 0);
        for (i = delta[j]; i >= 0; i--)
        {
            f_w = mzd_init_window(fT[i], j, 0, j + 1, f[i]->nrows);
            /*printf("%ld, %d\n", delta[j] - i, L);*/
            _mzd_mul_va(wT, f_w , mtzT[delta[j] - i], 0);
            mzd_free_window(f_w);
        }

        /*if (!w.transposed()[0].isZero() && (M*w).transposed()[0].isZero())*/
        mzd_transpose(w, wT);
        mzd_set_ui(Mw, 0);
        nmod_sparse_mat_mul_m4ri_mat(Mw, M, w); /* TODO can we use existing knowledge here */
        if (!mzd_is_zero(w))
        {
            if (mzd_is_zero(Mw))
            {
                printf("win");
            }
        }
    }
    for (j = 0; j < t + 1; j++)
        mzd_free(fT[j]);
    for (j = 0; j < L + 1; j++)
        mzd_free(mtzT[j]);
    free(mtzT);
    free(fT);
    mzd_free(w);
    mzd_free(Mw);

    /* cleanup */
    for (i = 0; i <= t; i++)
        mzd_free(f[i]);

    mzd_free(mtz[0]);
    for (i = 0; i < L; i++)
    {
        mzd_free(mty[i]);
        mzd_free(xmty[i]);
    }

    mzd_free(e);
    mzd_free(x);
    mzd_free(P[0]);
    mzd_free(P[1]);
    free(mtz);
    free(xmty);
    free(P);
    free(f);
}

int
main(int argc, char * argv[])
{
    nmod_sparse_mat_t M;
    n_primes_t primes;
    slong N = 12800, i, j;
    mp_limb_t p;
    float prob;
    mzd_t *K;

    /* create M randomly */
    n_primes_init(primes);
    nmod_sparse_mat_init(M, N, N, 2);
    /*
    for (j = 0; j < N; j++)
        nmod_sparse_mat_ensure_row_alloc(M, j, 30);
    */
    if (1)
    {
    for (p = n_primes_next(primes), i = 0; i < N; p = n_primes_next(primes), i++)
    {
        prob = 1.0f - pow(1.0f - 2.0f/(float)p, 8);
        for (j = 0; j < M->r; j++)
        {
            if (myrand() < prob)
            {
                _nmod_sparse_mat_set_entry(M, j, i, M->row_supports[j], 1);
            }
        }
    }
    }
    else
    {
    for (j = 1; j < N; j++)
    {
        _nmod_sparse_mat_set_entry(M, j, 0, 0, 1);
        _nmod_sparse_mat_set_entry(M, j, j, 1, 1);
    }
    }


    /*nmod_sparse_mat_print_pretty(M);*/

    K = mzd_init(N, 1);

    bw(K, M);

    mzd_free(K);

    nmod_sparse_mat_clear(M);

    return 0;
}
